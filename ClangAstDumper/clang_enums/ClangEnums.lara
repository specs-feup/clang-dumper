import HeaderEnums;
import ClangEnum;

/**
 * @class
 */
var ClangEnums = {};

/**


- clang/Basic/AttrKinds.h
attr::Kind, ATTRIBUTES 

 
- clang/Basic/Specifiers.h 
CallingConv, CALLING_CONVENTION 
AccessSpecifier, ACCESS_SPECIFIER
StorageClass, STORAGE_CLASS
ExplicitSpecKind, EXPLICIT_SPEC_KIND


- clang/AST/Type.h
ExceptionSpecificationType, EXCEPTION_SPECIFICATION_TYPE

- clang/Basic/Linkage.h
Linkage, LINKAGE

- clang/Basic/Visibility.h
Visibility, VISIBILITY

- clang/AST/TemplateBase.h
ArgKind, TEMPLATE_ARG_KIND


- clang/AST/Decl.h
InitializationStyle, INIT_STYLE
TLSKind, TLS_KIND

- clang/AST/ExprCXX.h
InitializationStyle, NEW_INIT_STYLE
ConstructionKind, CONSTRUCTION_KIND

- clang/Basic/TypeTraits.h
UnaryExprOrTypeTrait, UETT_KIND

- clang/Ast/NestedNameSpecifier.h
SpecifierKind, NESTED_NAMED_SPECIFIER

- clang/Ast/Expr.h
Kind, OFFSET_OF_NODE_KIND (class OffsetOfNode)
IdentKind, PREDEFINED_ID_TYPE
StringKind, STRING_KIND
Kind, DESIGNATOR_KIND (class Designator)


- clang/AST/DeclCxx.h
LanguageIDs, LINKAGE_LANGUAGE

- clang/Basic/Lambda.h
LambdaCaptureDefault, LAMBDA_CAPTURE_DEFAULT
LambdaCaptureKind, LAMBDA_CAPTURE_KIND


- clang/AST/TemplateName.h
NameKind, TEMPLATE_NAME_KIND

- clang/AST/Attr.h
VisibilityType, VISIBILITY_ATTR_TYPE



 */



ClangEnums._TYPE_H = new HeaderEnums('Type.h', [
	new ClangEnum('Kind', 'BUILTIN_KIND', undefined, ["LastKind"]),
	new ClangEnum('RefQualifierKind', 'REFERENCE_QUALIFIER', value => ClangEnums._refQualMapper(value), undefined),
	new ClangEnum('ArraySizeModifier', 'ARRAY_SIZE_MODIFIER', undefined, undefined),
	new ClangEnum('UTTKind', 'UTT_KIND', undefined, undefined),
	new ClangEnum('ElaboratedTypeKeyword', 'ELABORATED_TYPE_KEYWORD', value => ClangEnums._elaboratedTypeKeyworkMapper(value), undefined),
	new ClangEnum('TagTypeKind', 'TAG_KIND', value => ClangEnums._tagKindMapperMapper(value), undefined)
]);

ClangEnums._OPERATIONS_KINDS_H = new HeaderEnums('OperationKinds.h', [
	new ClangEnum('CastKind', 'CAST_KIND', value => ClangEnums._removePrefix(value, "CK_"), undefined),
	new ClangEnum('BinaryOperatorKind', 'BINARY_OPERATOR_KIND', value => ClangEnums._removePrefix(value, "BO_"), undefined),
	new ClangEnum('UnaryOperatorKind', 'UNARY_OPERATOR_KIND', value => ClangEnums._removePrefix(value, "UO_"), undefined)
]);

ClangEnums._HEADERS = [ClangEnums._TYPE_H, ClangEnums._OPERATIONS_KINDS_H];

ClangEnums.getHeader = function(headerFilename) {
	if(ClangEnums._HEADER_MAP === undefined) {
		ClangEnums._HEADER_MAP = ClangEnums.buildHeaderMap();
	}

	return ClangEnums._HEADER_MAP[headerFilename];
}

ClangEnums.buildHeaderMap = function() {
	var map = {};
	
	for(var header of ClangEnums._HEADERS) {
		map[header.getName()] = header;
	}
	//println("Header map");
	//printlnObject(map);
	return map;
}

/**
 * Mappers
 */
 ClangEnums._removePrefix = function(enumValue, prefix) {

	if(enumValue.startsWith(prefix)) {
		enumValue = enumValue.substring(prefix.length);
	}

	return enumValue;
}
 
ClangEnums._refQualMapper = function(enumValue) {
//println("MAPPER FOR " + enumValue);
	if(enumValue.startsWith("RQ_")) {
//	println("Starts with RQ_");
		enumValue = enumValue.substring(3);
	}
//	println("RETURNING: " + enumValue);
	return enumValue;
}

ClangEnums._elaboratedTypeKeyworkMapper = function(enumValue) {

	if(enumValue.startsWith("ETK_")) {
		enumValue = enumValue.substring(4);
	}
	
	enumValue = enumValue.toUpperCase();

	return enumValue;
}

ClangEnums._tagKindMapperMapper = function(enumValue) {

	if(enumValue.startsWith("TTK_")) {
		enumValue = enumValue.substring(4);
	}
	
	enumValue = enumValue.toUpperCase();

	return enumValue;
}