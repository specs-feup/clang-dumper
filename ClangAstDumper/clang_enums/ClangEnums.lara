import HeaderEnums;
import ClangEnum;

/**
 * @class
 */
var ClangEnums = {};

/**





- clang/AST/ExprCXX.h
InitializationStyle, NEW_INIT_STYLE
ConstructionKind, CONSTRUCTION_KIND

- clang/Basic/TypeTraits.h
UnaryExprOrTypeTrait, UETT_KIND

- clang/Ast/NestedNameSpecifier.h
SpecifierKind, NESTED_NAMED_SPECIFIER




- clang/AST/DeclCxx.h
LanguageIDs, LINKAGE_LANGUAGE

- clang/Basic/Lambda.h
LambdaCaptureDefault, LAMBDA_CAPTURE_DEFAULT
LambdaCaptureKind, LAMBDA_CAPTURE_KIND


- clang/AST/TemplateName.h
NameKind, TEMPLATE_NAME_KIND

- clang/AST/Attr.h
VisibilityType, VISIBILITY_ATTR_TYPE


- clang/Ast/Expr.h
Kind, OFFSET_OF_NODE_KIND (class OffsetOfNode)
IdentKind, PREDEFINED_ID_TYPE
StringKind, STRING_KIND
Kind, DESIGNATOR_KIND (class Designator)
 

 */



ClangEnums._TYPE_H = new HeaderEnums('Type.h', [
	new ClangEnum('Kind', 'BUILTIN_KIND', undefined, ["LastKind"]),
	new ClangEnum('RefQualifierKind', 'REFERENCE_QUALIFIER', value => ClangEnums._removePrefix(value, "RQ_"), undefined),
	new ClangEnum('ArraySizeModifier', 'ARRAY_SIZE_MODIFIER', undefined, undefined),
	new ClangEnum('UTTKind', 'UTT_KIND', undefined, undefined),
	new ClangEnum('ElaboratedTypeKeyword', 'ELABORATED_TYPE_KEYWORD', value => ClangEnums._removePrefix(value, "ETK_"), undefined),
	new ClangEnum('TagTypeKind', 'TAG_KIND', value => ClangEnums._removePrefix(value, "TTK_"), undefined)
]);


ClangEnums._OPERATIONS_KINDS_H = new HeaderEnums('OperationKinds.h', [
	new ClangEnum('CastKind', 'CAST_KIND', value => ClangEnums._removePrefix(value, "CK_"), undefined),
	new ClangEnum('BinaryOperatorKind', 'BINARY_OPERATOR_KIND', value => ClangEnums._removePrefix(value, "BO_"), undefined),
	new ClangEnum('UnaryOperatorKind', 'UNARY_OPERATOR_KIND', value => ClangEnums._removePrefix(value, "UO_"), undefined)
]);


ClangEnums._ATTR_KINDS_H = new HeaderEnums('AttrKinds.h', [
	new ClangEnum('Kind', 'ATTRIBUTES', undefined, undefined)
]);


ClangEnums._SPECIFIERS_H = new HeaderEnums('Specifiers.h', [
	new ClangEnum('CallingConv', 'CALLING_CONVENTION', value => ClangEnums._removePrefix(value, "CC_"), undefined),
	new ClangEnum('AccessSpecifier', 'ACCESS_SPECIFIER', value => ClangEnums._removePrefix(value, "AS_"), undefined),
	new ClangEnum('StorageClass', 'STORAGE_CLASS', value => ClangEnums._removePrefix(value, "SC_"), undefined),
	new ClangEnum('ExplicitSpecKind', 'EXPLICIT_SPEC_KIND', undefined, undefined)	
]);



ClangEnums._EXCEPTION_SPECIFICATION_TYPE_H = new HeaderEnums('ExceptionSpecificationType.h', [
	new ClangEnum('ExceptionSpecificationType', 'EXCEPTION_SPECIFICATION_TYPE', value => ClangEnums._removePrefix(value, "EST_"), undefined)
]);

ClangEnums._LINKAGE_H = new HeaderEnums('Linkage.h', [
	new ClangEnum('Linkage', 'LINKAGE', value => ClangEnums._removePrefix(value, "EST_"), undefined)
]);

ClangEnums._VISIBILITY_H = new HeaderEnums('Visibility.h', [
	new ClangEnum('Visibility', 'VISIBILITY', value => ClangEnums._removeSuffix(value, "Visibility"), undefined)
]);

ClangEnums._TEMPLATE_BASE_H = new HeaderEnums('TemplateBase.h', [
	new ClangEnum('ArgKind', 'TEMPLATE_ARG_KIND', undefined, undefined)
]);

ClangEnums._DECL_H = new HeaderEnums('Decl.h', [
	new ClangEnum('InitializationStyle', 'INIT_STYLE', undefined, undefined),
	new ClangEnum('TLSKind', 'TLS_KIND', undefined, undefined)	
]);



ClangEnums._HEADERS = [ClangEnums._TYPE_H, 
	ClangEnums._OPERATIONS_KINDS_H, 
	ClangEnums._ATTR_KINDS_H,
	ClangEnums._SPECIFIERS_H,
	ClangEnums._EXCEPTION_SPECIFICATION_TYPE_H,
	ClangEnums._LINKAGE_H,
	ClangEnums._VISIBILITY_H,
	ClangEnums._TEMPLATE_BASE_H,
	ClangEnums._DECL_H
];

ClangEnums.getHeader = function(headerFilename) {
	if(ClangEnums._HEADER_MAP === undefined) {
		ClangEnums._HEADER_MAP = ClangEnums.buildHeaderMap();
	}

	return ClangEnums._HEADER_MAP[headerFilename];
}

ClangEnums.buildHeaderMap = function() {
	var map = {};
	
	for(var header of ClangEnums._HEADERS) {
		map[header.getName()] = header;
	}
	//println("Header map");
	//printlnObject(map);
	return map;
}

/**
 * Mappers
 */
ClangEnums._removePrefix = function(enumValue, prefix) {

	if(enumValue.startsWith(prefix)) {
		enumValue = enumValue.substring(prefix.length);
	}

	return enumValue;
}


ClangEnums._removeSuffix = function(enumValue, suffix) {

	if(enumValue.endsWith(suffix)) {
		enumValue = enumValue.substring(0, enumValue.length - suffix.length);
	}

	return enumValue;
}
 
/*
ClangEnums._refQualMapper = function(enumValue) {
//println("MAPPER FOR " + enumValue);
	if(enumValue.startsWith("RQ_")) {
//	println("Starts with RQ_");
		enumValue = enumValue.substring(3);
	}
//	println("RETURNING: " + enumValue);
	return enumValue;
}
*/
/*
ClangEnums._elaboratedTypeKeyworkMapper = function(enumValue) {

	if(enumValue.startsWith("ETK_")) {
		enumValue = enumValue.substring(4);
	}
	
	enumValue = enumValue.toUpperCase();

	return enumValue;
}
*/
/*
ClangEnums._tagKindMapperMapper = function(enumValue) {

	if(enumValue.startsWith("TTK_")) {
		enumValue = enumValue.substring(4);
	}
	
	enumValue = enumValue.toUpperCase();

	return enumValue;
}
*/