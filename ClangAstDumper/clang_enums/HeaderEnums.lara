import lara.util.StringSet;
import lara.Io;

/**
 * @class
 */
var HeaderEnums = function(headerFilename, clangEnums) {
	this.headerFilename = headerFilename;
	this.enumMap = {};
	this.currentEnumSet = new StringSet();
	
	for(var clangEnum of clangEnums) {
		this.enumMap[clangEnum.getEnumName()] = clangEnum;
		this.currentEnumSet.add(clangEnum.getEnumName());
	}
};

HeaderEnums.prototype.getName = function() {
	return this.headerFilename;
}

HeaderEnums.prototype.process = function($enum) {
	// Check if valid enum
	if(!this.currentEnumSet.has($enum.name)) {
		return;
	}

	println("Adding enum '"+$enum.name+"'");

	// Set enums
	var enumValues = $enum.enumerators.map($enumValue => $enumValue.name);	
	this.enumMap[$enum.name].setEnumValues(enumValues);
	
	// Save enums, for referece
	var filename = this.headerFilename.replace(".", "_") + "_" + $enum.name +  ".txt";
	var file = Io.getPath(filename);
	println("Saving enum values to file '"+file.getAbsolutePath()+"'");
	Io.writeFile(filename, enumValues.join("\n"));
}
	
HeaderEnums.prototype.generateCode = function(outputFolder) {

	var filename = "enums_" + this.headerFilename.replace(".", "_") + ".cpp";

	var code = '#include "ClangEnums.h"\n\n';

	// Generate code for each of the enums
	for(var enumName in this.enumMap) {
		var enumCode = this.enumMap[enumName].getCode();
		
		if(enumCode === undefined) {
			println("Skipped code generation for " + this.headerFilename + "::" + enumName);
			continue;
		}
		
		code += enumCode + "\n";
	}
	
	Io.writeFile(Io.getPath(outputFolder, filename), code);
}	
